# Phase IV: Local Kubernetes Deployment Constitution

## CORE PRINCIPLES

1. **Zero Manual Code**: All implementation must be generated by Claude Code from specifications
2. **AI-First Infrastructure**: Use kubectl-ai, kagent, and Docker AI (Gordon) for all infrastructure operations
3. **Production-Ready Local**: Minikube deployment must mirror cloud production environment
4. **Spec-Driven Everything**: Every component must have a specification before implementation
5. **Stateless by Design**: Applications must be stateless, with state in Neon PostgreSQL

## TECHNOLOGY STACK CONSTRAINTS

- **Containerization**: Docker (Docker Desktop with Gordon AI)
- **Orchestration**: Minikube (local Kubernetes)
- **Package Manager**: Helm Charts
- **AI DevOps Tools**: kubectl-ai, kagent
- **Database**: Neon Serverless PostgreSQL (external)
- **Application**: Phase III Todo Chatbot (FastAPI + Next.js + Gemini AI + MCP)

## ARCHITECTURAL CONSTRAINTS

1. All services must be containerized
2. No hardcoded secrets in containers
3. Environment variables for all configuration
4. Health checks for all services
5. Resource limits and requests defined
6. Horizontal pod autoscaling configured
7. Persistent volumes only for non-stateless data

## DEVELOPMENT WORKFLOW

1. Write specification in `/specs/`
2. Generate plan using Claude Code
3. Break into tasks
4. Implement via Claude Code
5. Test with kubectl-ai
6. Iterate on specification

## SECURITY CONSTRAINTS

1. No root user in containers
2. Read-only root filesystem where possible
3. Non-privileged containers
4. Secrets managed via Kubernetes Secrets
5. Network policies for pod communication

## DEPLOYMENT STRATEGY

1. Helm charts for all deployments
2. Rolling updates for zero-downtime
3. Liveness and readiness probes
4. Horizontal Pod Autoscaler (HPA)
5. Resource quotas

## MONITORING REQUIREMENTS

1. Basic logging to stdout/stderr
2. Health endpoints (/health, /ready)
3. Prometheus metrics exposure
4. Basic Grafana dashboard for resource usage
