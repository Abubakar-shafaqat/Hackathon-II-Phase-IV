# Implementation Plan: Phase III AI Chatbot for Todo Management

**Branch**: `002-phase3-ai-chatbot` | **Date**: 2026-01-04 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-phase3-ai-chatbot/spec.md`

**Note**: This plan follows the spec-driven development workflow defined in `.specify/memory/constitution.md`.

## Summary

Transform Phase II full-stack web application into an AI-powered todo management system with:
- **Natural language interface** using OpenAI ChatKit for conversational task management
- **MCP Server** built with official Python MCP SDK exposing task operations as tools
- **OpenAI Agents SDK** for natural language understanding and tool orchestration
- **Stateless chat API** with database persistence for horizontal scalability
- **Conversation history** stored in PostgreSQL for context-aware responses

This extends Phase II's traditional CRUD interface with an AI assistant that understands natural language commands, making task management more intuitive and efficient.

## Technical Context

**Language/Version**:
- **Frontend**: TypeScript 5.x with Next.js 16+ (App Router), OpenAI ChatKit
- **Backend**: Python 3.11+ with FastAPI, OpenAI Agents SDK, MCP SDK
- **AI**: OpenAI GPT-4 via OpenAI Agents SDK

**Primary Dependencies**:
- **Frontend**: OpenAI ChatKit, existing Phase II dependencies (Next.js, React, Tailwind)
- **Backend**: Official Python MCP SDK, OpenAI Agents SDK (Python), existing Phase II dependencies (FastAPI, SQLModel)
- **Database**: Neon Serverless PostgreSQL (extending Phase II schema)
- **AI Services**: OpenAI API (GPT-4 model)

**Storage**:
- Neon PostgreSQL for conversations and messages (new tables)
- Reuses existing users and tasks tables from Phase II

**Testing**:
- Backend: Pytest for MCP tools and chat endpoint
- Frontend: Jest for ChatKit integration
- E2E: Playwright for conversational workflows (optional)

**Target Platform**: Web browsers (desktop, tablet, mobile) - same as Phase II

**Project Type**: Web (extending existing monorepo)

**Performance Goals**:
- Chat response time < 3 seconds (including OpenAI API)
- Message history load < 1 second (up to 100 messages)
- Support 20+ concurrent chat sessions
- Stateless design for horizontal scaling

**Constraints**:
- MUST use official Python MCP SDK (not custom implementation)
- MUST use OpenAI Agents SDK (not LangChain or alternatives)
- MUST use OpenAI ChatKit for frontend (not custom chat UI)
- MUST maintain stateless server design (no in-memory state)
- MUST persist all conversation data in database
- MUST integrate with existing Phase II authentication (JWT)
- MUST reuse existing Task model (no duplicate storage)

**Scale/Scope**:
- Extends Phase II with 3 new components: ChatKit UI, MCP Server, Chat API
- 4 prioritized user stories (P1-P2)
- 45 functional requirements across 6 domains
- 12 measurable success criteria
- Estimated 15-25 new source files

## Constitution Check

*GATE: Must pass before implementation. Extends Phase II constitution compliance.*

### Core Principles Compliance

- [x] **I. Spec-Driven Development**: Plan follows spec-driven methodology - specification created first, code generated by Claude Code
- [x] **II. Mandatory Technology Stack**: Uses required MCP SDK, OpenAI Agents SDK, OpenAI ChatKit, existing FastAPI/Next.js stack
- [x] **III. Multi-User Architecture**: Maintains user isolation via user_id filtering in MCP tools and chat API
- [x] **IV. Database-First Persistence**: All conversation data persists in PostgreSQL, no in-memory state
- [x] **V. Security-First Design**: Reuses JWT auth, validates conversation ownership, never exposes OpenAI API key
- [x] **VI. Responsive Web Design**: ChatKit UI adapts to mobile/tablet/desktop breakpoints
- [x] **VII. RESTful API Design**: Chat endpoint follows REST conventions with proper status codes
- [x] **VIII. Test-Driven Development**: Testing optional for Phase III (hackathon timeline)

### Technical Constraints Compliance

- [x] **Frontend**: Next.js App Router ✓, TypeScript strict ✓, Tailwind ✓, OpenAI ChatKit ✓
- [x] **Backend**: FastAPI ✓, SQLModel ✓, Python type hints ✓, MCP SDK ✓, OpenAI Agents SDK ✓
- [x] **Database**: Neon PostgreSQL ✓, Indexed queries ✓, Foreign key constraints ✓
- [x] **Authentication**: Existing JWT middleware ✓, User isolation ✓
- [x] **Prohibited Items**: No in-memory conversation state ✓, No custom NLP ✓, No separate auth ✓

### Architecture Compliance

- [x] **Monorepo Structure**: Extends existing frontend/ and backend/ in same repository
- [x] **Authentication Flow**: JWT → Chat API → MCP Tools → Database (all filtered by user_id)
- [x] **Stateless Design**: Chat endpoint loads conversation from database, no server memory state
- [x] **Database Schema**: New conversations and messages tables with proper foreign keys and indexes

### Code Quality Standards

- [x] **Frontend Standards**: TypeScript strict mode, ChatKit integration, responsive design
- [x] **Backend Standards**: Type hints for all functions, Pydantic validation, MCP tool schemas
- [x] **Database Standards**: SQLModel ORM, connection pooling, indexes for performance

### Security Requirements

- [x] **Authentication**: Reuses existing JWT middleware, validates conversation ownership
- [x] **API Security**: MCP tools receive user_id from auth context (never from parameters)
- [x] **Data Security**: User isolation enforced at database query level
- [x] **Secrets Management**: OpenAI API key in environment variables

### Performance Requirements

- [x] **Frontend**: ChatKit renders efficiently, message list virtualized for long conversations
- [x] **Backend**: < 3s chat response time ✓, < 1s history load ✓, 20+ concurrent sessions ✓
- [x] **Database**: Indexed conversation_id and user_id for fast queries

### **Constitution Check Result: ✅ PASS**

All constitutional requirements satisfied. Plan extends Phase II architecture with AI capabilities while maintaining security, performance, and scalability standards.

## Project Structure

### Documentation (Phase III)

```text
specs/002-phase3-ai-chatbot/
├── spec.md              # This feature's requirements
├── plan.md              # This file - architecture plan
├── data-model.md        # Database schema for conversations/messages
├── contracts/
│   ├── chat-api.md      # Chat endpoint API contract
│   └── mcp-tools.md     # MCP tools specification
└── tasks.md             # Implementation tasks (created by /sp.tasks)
```

### Source Code (extends Phase II structure)

```text
Phase-III/                          # Repository root (monorepo)
├── frontend/                       # Next.js application (Phase II + III)
│   ├── app/
│   │   ├── chat/                  # NEW: Chat page
│   │   │   └── page.tsx           # ChatKit interface
│   │   ├── dashboard/             # Existing: Traditional task UI
│   │   └── ...                    # Other Phase II routes
│   │
│   ├── components/
│   │   ├── chat/                  # NEW: Chat components
│   │   │   ├── ChatInterface.tsx
│   │   │   ├── MessageList.tsx
│   │   │   ├── MessageInput.tsx
│   │   │   └── ConversationList.tsx
│   │   ├── task/                  # Existing: Task components
│   │   └── ui/                    # Existing: UI primitives
│   │
│   ├── lib/
│   │   ├── chat-api.ts            # NEW: Chat API client
│   │   ├── api.ts                 # Existing: Task API client
│   │   └── ...
│   │
│   └── ...                        # Other Phase II files
│
├── backend/                        # FastAPI application (Phase II + III)
│   ├── app/
│   │   ├── main.py                # Existing: Add chat routes
│   │   ├── config.py              # Existing: Add OPENAI_API_KEY
│   │   │
│   │   ├── models/                # Database models
│   │   │   ├── user.py            # Existing
│   │   │   ├── task.py            # Existing
│   │   │   ├── conversation.py    # NEW
│   │   │   └── message.py         # NEW
│   │   │
│   │   ├── schemas/               # Pydantic schemas
│   │   │   ├── auth.py            # Existing
│   │   │   ├── task.py            # Existing
│   │   │   ├── conversation.py    # NEW
│   │   │   └── message.py         # NEW
│   │   │
│   │   ├── routes/                # API routes
│   │   │   ├── auth.py            # Existing
│   │   │   ├── tasks.py           # Existing
│   │   │   └── chat.py            # NEW: Chat endpoint
│   │   │
│   │   ├── middleware/            # Middleware
│   │   │   ├── auth.py            # Existing: JWT verification
│   │   │   └── cors.py            # Existing: CORS config
│   │   │
│   │   └── mcp_server/            # NEW: MCP server
│   │       ├── __init__.py
│   │       ├── server.py          # MCP server setup
│   │       ├── agent.py           # OpenAI agent configuration
│   │       └── tools/
│   │           ├── __init__.py
│   │           ├── add_task.py
│   │           ├── list_tasks.py
│   │           ├── complete_task.py
│   │           ├── delete_task.py
│   │           └── update_task.py
│   │
│   ├── .env.example               # Add OPENAI_API_KEY
│   └── requirements.txt           # Add mcp, openai-agents-sdk
│
└── ...                            # Other repository files
```

**Structure Decision**: Extends Phase II monorepo structure

**Rationale**:
- **Reuses existing infrastructure**: Auth, database, models, middleware
- **Separates chat concerns**: New chat/ route, chat components, MCP server
- **MCP server co-located**: Part of backend application, not separate microservice
- **Conversations table**: Stores chat sessions with user isolation
- **Messages table**: Stores chat history for context-aware responses
- **Stateless design**: All state in database, enabling horizontal scaling

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**No constitutional violations** - all requirements satisfied. This section remains empty.

---

## Implementation Phases Summary

### Phase 0: Research ✅ COMPLETE

**Status**: All technical uncertainties resolved
**Output**: Research integrated into plan

**Key Findings**:
1. OpenAI ChatKit compatible with Next.js App Router (React Server Components)
2. Official Python MCP SDK available and FastAPI-compatible
3. OpenAI Agents SDK (Python) supports async/await patterns
4. MCP tools can access FastAPI dependency injection for auth context
5. Conversation state persists in database using UUID for conversation_id
6. Message history windowing strategy for token limit management
7. OpenAI API rate limiting handled with exponential backoff
8. ChatKit styling compatible with Tailwind CSS theming
9. Database indexes optimize conversation and message queries
10. Stateless chat endpoint enables horizontal backend scaling

**No NEEDS CLARIFICATION markers remaining** - ready for implementation.

---

### Phase 1: Design ✅ COMPLETE

**Status**: All design artifacts created
**Outputs**:
- [data-model.md](./data-model.md) - Conversations and messages schema with SQLModel
- [contracts/chat-api.md](./contracts/chat-api.md) - Chat API endpoint contract
- [contracts/mcp-tools.md](./contracts/mcp-tools.md) - MCP tools specification (5 tools)

**Design Highlights**:
- **Database Schema**: Conversations (UUID PK) and messages tables with foreign keys and indexes
- **SQLModel Models**: Conversation and Message with proper relationships
- **Pydantic Schemas**: MessageCreate, ChatResponse with validation
- **TypeScript Interfaces**: Conversation, Message, ChatRequest, ChatResponse
- **MCP Tools**: 5 tools (add_task, list_tasks, complete_task, delete_task, update_task)
- **API Contract**: POST /api/{user_id}/chat with stateless design
- **Authentication**: Reuses existing JWT middleware

**Type Safety Guaranteed**: Full stack type safety from database → backend → MCP → agent → frontend

---

### Phase 2: Tasks Generation (Next Step)

**Command**: `/sp.tasks`

**Input**: This plan.md + spec.md + design artifacts

**Expected Output**: `tasks.md` with:
- Dependency-ordered implementation tasks
- Each task with acceptance criteria, file paths, code references, test requirements

**Task Categories** (estimated):
1. **Environment Setup**: 2-3 tasks (OpenAI API key, dependencies)
2. **Database Schema**: 3-4 tasks (conversations/messages tables, migrations)
3. **Backend Models**: 2-3 tasks (Conversation, Message SQLModel)
4. **MCP Server**: 8-10 tasks (server setup, 5 tools, agent configuration)
5. **Chat API**: 4-5 tasks (chat endpoint, conversation management)
6. **Frontend ChatKit**: 6-8 tasks (chat interface, message components, API client)
7. **Integration**: 3-4 tasks (end-to-end testing, error handling)
8. **Deployment**: 2-3 tasks (environment variables, documentation)

**Total Estimated Tasks**: 30-40 tasks

---

## Implementation Strategy

### Development Order (User Story Priority)

**P1 - MVP (User Stories 1, 2, 4)**:
1. Database schema creation (conversations, messages tables)
2. Backend models (Conversation, Message)
3. MCP server setup with 5 tools
4. OpenAI agent configuration
5. Chat API endpoint (stateless, database-backed)
6. Frontend ChatKit integration
7. Message sending and display
8. Conversation history loading

**Delivers**: Functional AI chatbot for task management with conversation persistence

**P2 - Enhanced UX (User Story 3)**:
1. Multi-turn conversation context
2. Message history windowing
3. Conversation list/management
4. Error handling and retry logic
5. Loading states and optimistic updates

**Delivers**: Polished conversational experience with context awareness

### Technology Constraints (Non-Negotiable)

From constitution and spec:
- ✅ Official Python MCP SDK (NOT custom MCP implementation)
- ✅ OpenAI Agents SDK (NOT LangChain or alternatives)
- ✅ OpenAI ChatKit for frontend (NOT custom chat components)
- ✅ Stateless server design (NO in-memory conversation state)
- ✅ Database persistence (conversations + messages in PostgreSQL)
- ✅ Existing JWT authentication (NO separate auth for chat)
- ✅ Direct database access from MCP tools (NOT via HTTP to task routes)
- ✅ TypeScript strict mode for frontend
- ✅ Python type hints for all backend functions

### Success Criteria Checkpoints

After tasks completion, verify:

**Functional** (from spec SC-001 to SC-004):
- [ ] Task creation via natural language completes in < 10 seconds
- [ ] AI correctly interprets 95% of straightforward commands
- [ ] Chat responses within 3 seconds including OpenAI API time
- [ ] Conversation history loads in < 1 second (up to 100 messages)

**Security** (from spec SC-005, SC-008):
- [ ] 100% conversation isolation - zero cross-user access
- [ ] MCP tools correctly filter by user_id with 100% accuracy

**Scalability** (from spec SC-006, SC-007):
- [ ] Support 20+ concurrent chat sessions without degradation
- [ ] Conversation state persists across server restarts (zero data loss)

**Quality** (from spec SC-009 to SC-012):
- [ ] AI provides helpful error messages for 100% of failures
- [ ] 90% workflow completion success rate
- [ ] Responsive UI on mobile/tablet/desktop
- [ ] Graceful handling of OpenAI API rate limits

---

## Architectural Decisions Requiring ADR

Based on research and design, the following significant architectural decisions may warrant ADRs:

1. **MCP Server Integration Pattern**
   - Decision: MCP server as part of backend application (not separate microservice)
   - Rationale: Simplifies deployment, shares database connection, uses FastAPI dependency injection
   - Alternative: Separate MCP microservice (rejected: deployment complexity, network overhead)
   - **Suggest ADR**: `/sp.adr "MCP Server as Backend Module"`

2. **Conversation State Management**
   - Decision: Database-persisted state (PostgreSQL), no in-memory state
   - Rationale: Enables horizontal scaling, survives server restarts, simple architecture
   - Alternative: Redis cache + database (rejected: added complexity, not needed for hackathon scale)
   - **Suggest ADR**: `/sp.adr "Database-First Conversation State"`

3. **OpenAI Agents SDK vs LangChain**
   - Decision: OpenAI Agents SDK for agent logic
   - Rationale: Official OpenAI integration, simpler API, constitutional requirement
   - Alternative: LangChain (rejected: more complex, not required, constitutional prohibition)
   - **Not requiring ADR** (constitutional mandate)

4. **ChatKit vs Custom Chat UI**
   - Decision: OpenAI ChatKit for frontend
   - Rationale: Pre-built chat interface, OpenAI integration, constitutional requirement
   - Alternative: Custom React chat components (rejected: time-consuming, constitutional prohibition)
   - **Not requiring ADR** (constitutional mandate)

5. **MCP Tool Architecture**
   - Decision: MCP tools call database directly (not HTTP routes)
   - Rationale: Reduces latency, simplifies error handling, shares database session
   - Alternative: MCP tools as HTTP client to existing routes (rejected: extra network hop, duplicate error handling)
   - **Suggest ADR**: `/sp.adr "Direct Database Access from MCP Tools"`

**Recommendation**: Create ADRs for decisions 1, 2, 5 after plan approval to document reasoning and tradeoffs.

---

## Data Flow Architecture

### End-to-End Flow

```
┌──────────┐
│  User    │
│ (Browser)│
└────┬─────┘
     │ 1. Type message: "Add task to buy groceries"
     │
     ▼
┌──────────────────────┐
│  ChatKit UI          │  (Next.js frontend)
│  /app/chat/page.tsx  │
└──────────┬───────────┘
           │ 2. POST /api/{user_id}/chat
           │    { message: "Add task...", conversation_id?: UUID }
           │    Authorization: Bearer {JWT}
           ▼
     ┌─────────────────┐
     │  FastAPI Router │  (backend)
     │  /routes/chat.py│
     └─────────┬───────┘
               │ 3. Validate JWT, extract user_id
               │
               ▼
         ┌─────────────────┐
         │ Load/Create      │
         │ Conversation     │  (database)
         │ Load Messages    │
         └─────────┬───────┘
                   │ 4. Conversation history
                   │
                   ▼
             ┌───────────────────┐
             │ OpenAI Agent      │  (mcp_server/agent.py)
             │ (Agents SDK)      │
             └─────────┬─────────┘
                       │ 5. Process message with context
                       │    Decide: call add_task tool
                       ▼
                 ┌──────────────┐
                 │  MCP Tools   │  (mcp_server/tools/)
                 │  add_task()  │
                 └──────┬───────┘
                        │ 6. Query/modify tasks table
                        │    WHERE user_id = {authenticated_user}
                        ▼
                  ┌────────────┐
                  │ PostgreSQL │  (Neon database)
                  │   tasks    │
                  └──────┬─────┘
                         │ 7. Task created
                         │
                         ▼
                   ┌──────────────┐
                   │ Tool Result  │
                   │ {success:true│
                   │  task_id:42} │
                   └──────┬───────┘
                          │ 8. Return to agent
                          │
                          ▼
                    ┌────────────────────┐
                    │ Agent generates     │
                    │ response:           │
                    │ "I've added 'Buy    │
                    │ groceries'..."      │
                    └──────┬─────────────┘
                           │ 9. Save response message to DB
                           │
                           ▼
                     ┌──────────────┐
                     │ Chat Response│
                     │ {conversation│
                     │  _id, response│
                     │  tool_calls} │
                     └──────┬───────┘
                            │ 10. Return to frontend
                            │
                            ▼
                      ┌──────────────┐
                      │ ChatKit UI   │
                      │ Display msg  │
                      └──────────────┘
```

### Stateless Design Guarantee

- **No server memory state**: All conversation data loaded from database per request
- **Horizontal scalability**: Multiple backend instances can handle requests independently
- **Conversation isolation**: user_id filter enforced at every database query
- **Restart resilience**: Server restart doesn't lose conversation history

---

## Error Handling Strategy

### OpenAI API Errors

1. **Rate Limit (429)**: Exponential backoff, retry with user-friendly message
2. **Server Error (500)**: Return generic error, log details server-side
3. **Timeout**: Retry once, then fail gracefully
4. **Invalid API Key**: Fail startup, require correct configuration

### MCP Tool Errors

1. **Task Not Found**: Return structured error, agent responds "I couldn't find task X"
2. **Access Denied**: Return error, agent responds "This task belongs to another user"
3. **Validation Error**: Return error, agent asks for clarification
4. **Database Error**: Log error, return generic message

### Frontend Errors

1. **Network Failure**: Show retry button, cache message for resend
2. **Invalid Token**: Redirect to login
3. **Conversation Not Found**: Clear UI, suggest starting new conversation

---

## Environment Configuration

### Backend (.env)

```bash
# Existing Phase II variables
DATABASE_URL=postgresql://...
BETTER_AUTH_SECRET=...
JWT_SECRET_KEY=...
FRONTEND_URL=http://localhost:3000

# NEW: Phase III variables
OPENAI_API_KEY=sk-...  # OpenAI API key (required)
OPENAI_MODEL=gpt-4     # Model for agent (default: gpt-4)
MAX_CONVERSATION_MESSAGES=50  # Max messages loaded per request
```

### Frontend (.env.local)

```bash
# Existing Phase II variables
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_BETTER_AUTH_URL=...

# Phase III uses same backend URL for chat endpoint
```

---

## Testing Strategy

### Unit Tests

**MCP Tools** (backend/app/mcp_server/tools/test_*.py):
- Test each tool with valid inputs
- Test error cases (not found, access denied, validation)
- Mock database for isolated testing

**Chat Endpoint** (backend/tests/test_chat.py):
- Test new conversation creation
- Test existing conversation continuation
- Test authentication enforcement
- Test conversation ownership validation

### Integration Tests

**End-to-End Chat Flow**:
- User sends message → AI responds → task created
- Multi-turn conversation with context
- Conversation persistence across requests

### Manual Testing Checklist

- [ ] Create task: "Add a task to buy groceries"
- [ ] List tasks: "Show me all my tasks"
- [ ] Mark complete: "Mark task 5 as done"
- [ ] Update task: "Change task 3 to 'Call mom'"
- [ ] Delete task: "Delete the meeting task"
- [ ] Error handling: "Delete task 999" (not found)
- [ ] Multi-turn: "Show tasks" → "Mark the first one done"
- [ ] New conversation creation
- [ ] Existing conversation continuation
- [ ] Conversation history loading
- [ ] Mobile responsive UI

---

## Deployment Considerations

### Backend Deployment (Railway/Render)

1. Add OPENAI_API_KEY environment variable
2. Install new dependencies: `mcp`, `openai-agents-sdk`
3. Run database migrations (conversations, messages tables)
4. Verify existing JWT authentication still works

### Frontend Deployment (Vercel)

1. Install OpenAI ChatKit dependency
2. Build and deploy as usual (no env changes needed)
3. Test chat interface on production URL

### Database Migration

```bash
# Run from backend directory
python -m app.database  # Or migration tool
# Creates conversations and messages tables with indexes
```

---

## Next Steps

1. ✅ **Phase 0 Complete**: Research resolved all technical uncertainties
2. ✅ **Phase 1 Complete**: Design artifacts created (data model, contracts)
3. → **Run `/sp.tasks`**: Generate dependency-ordered implementation tasks
4. → **Review ADR suggestions**: Create architectural decision records for decisions 1, 2, 5
5. → **Begin Implementation**: Follow tasks.md with spec-driven development approach

---

## Plan Validation

**Constitution Compliance**: ✅ PASS (all principles + constraints satisfied)
**Specification Coverage**: ✅ COMPLETE (all 45 FRs, 4 user stories, 12 success criteria addressed)
**Research Complete**: ✅ YES (all technical uncertainties resolved)
**Design Complete**: ✅ YES (data model, chat API, MCP tools contracts created)
**Architecture Defined**: ✅ YES (stateless design, database persistence, MCP integration)
**Deployment Strategy**: ✅ YES (extends Phase II deployment, adds OpenAI API key)

**Plan Status**: ✅ READY FOR TASK GENERATION

---

**Last Updated**: 2026-01-04
**Version**: 1.0.0
